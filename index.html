<!DOCTYPE html>
<html>
    <head>
        <title>Ajay Poshak's blog</title>
        <meta name="viewport" content="width=device-width,initial-scale=1">
        <link href="./style.css" rel="stylesheet" />
        <link href="https://fonts.googleapis.com/css?family=Roboto&display=swap" rel="stylesheet">
        <link href="highlight/styles/a11y-light.css" rel="stylesheet" />
    </head>
    <body>
        <nav class="header">
            <section>
                <h1 class="header__name">Ajay Poshak</h1>
                <h2 class="header__company">Engineer @ BookMyShow</h2>
            </section>
            <section class="social-links">
                <a href="https://twitter.com/poshakajay">
                    <img src="icons/Twitter_Social_Icon_Circle_White.svg" alt="twitter" />
                </a>
                <a href="https://github.com/ajayposhak">
                    <img src="icons/GitHub-Mark-Light-64px.png" alt="github" />
                </a>
            </section>
        </nav>
        <section class="article">
            <header class="article-header">
                <h2 class="article-header__text">Lazy Evaluation of JS Code</h2>
                <time class="article-header__time" datetime="24-08-2019">August 24, 2019</time>
            </header>
            <article class="content">
                <p>Browsers are single threaded which means that they can do single thing at a time.
                    You may need to prioritize among different tasks to run more important tasks
                    first and defer the execution of other non-important tasks.</p>
                    
                    <p>For example, while scrolling a listing page, scroll event fires.  This event
                        adds some DOM elements to the list to achieve infinite scroll effect. But at
                        the same time, an analytics event is also fired, thus eating up the precious time
                        from the main thread, thus delaying the code to append DOM elements in the list.
                    </p>

                    <p>From a long time, this can be achieved via <code class="code">setTimeout</code>.  
                    Using setTimeout, non-important tasks can be pushed into callback queue. In callback queue,
                    after it completes the <code class="code">delay</code> time, the Event Loop pushes it into
                    call stack whenever it finds call stack empty.  Problem with this approach is that
                    we can't have the fine grained control over when the task would be executed.</p>
                    
                    <p>Recently an API called <code class="code">requestIdleCallback</code> 
                    has been added that tells when the main thread would be idle.  So  instead of
                    relying on the interplay of callback queue and callstack, we can 
                    reliabily defer the execution of non-essential tasks.</p>
                    
                    <p>One of such use cases are analytics.  Analytics while being extremely useful
                    to provide valuable insights into user behaviour, at the same time is not 
                    valuable to user experience.  So it makes a good case of lazy execution of code.</p>
                    
                    <p>Now we want to push execution of analytics calls to <code class="code">requestIdleCallback</code> so it
                    won't block the execution of essential tasks.</p>
                    
                    <p>But there might be some edge cases around this approach.  One, what if
                    user closes the browser tab or the browser itself before the main thread becomes
                    idle.  Surely, we don't want to loose those events.</p>
                    
                    <p>Another, what if main thread never becomes idle. So we need some
                    sort of guarantee that we won't miss the analytics events in case of any of these
                    edge cases occur.</p>
                    
                    
                    <p>Both of the above cases can be handled by building a wrapper around <code class="code">requestIdleCallback</code>
                    that guarantees that these events would be executed. That wrapper could use the
                    <code class="code">beforeunload</code> event that fires before a page/tab is closed.</p>
                    
                    <p>So our solution, essentially would be a queue of events.  Whenever an analytics
                    event occurs, it'll be pushed to the queue. On every callback of <code class="code">requestIdleCallback</code>
                    an event would be removed from the queue and passed to the <code class="code">requestIdleCallback</code>.</p>
                    
                    <p>This wrapper would also listen to the <code class="code">beforeunload</code> event, and whenever this event
                    called, wrapper would execute all events in the queue synchronously. Thus, providing
                    guarantee of execution also.</p>
                    <pre>
                        <code class="javascript">
class EventsQueue {
    static instance
    constructor() {
        if(typeof instance !== 'undefined') {
            return instance
        }
        this.taskQueue = []
        window.addEventListener('beforeunload', this.runImmediately, true)
        window.addEventListener('onVisibilityChange', this.onVisibilityChange, true)
    }

    push = (task) => {
        this.taskQueue.push(task)
        // Schedule Tasks to run as soon as they're added in queue
        this.scheduleTaskToRun()
    }

    isEmpty = () => {
        return this.taskQueue.length === 0
    }

    runImmediately = () => {
        while(!this.isEmpty()) {
            const task = this.taskQueue.shift()
            task()
        }
    }

    /**
    * Schedules tasks to run in rIC
    * @memberof EventsQueue
    */
    scheduleTaskToRun = () => {
        if(!this.isEmpty()) {
            const task = this.taskQueue.shift()
            this.runTask(task)
        }
    }

    /**
    * Gives the task to rIC to execute.  And also
    * schedules another one for next rIC, if queue
    * is not empty yet.
    * @memberof EventsQueue
    */
    runTask = (task) => {
        requestIdleCallback(task)
        if(!this.isEmpty()) {
            requestIdleCallback(this.execute())
        }
    }

    onVisibilityChange = () => {
        if(document.visibilityState === 'hidden') {
            this.runImmediately()
        }
    }

    
}

export default new EventsQueue()
                        </code>
                    </pre>
                    <p>Implementation <code class="code">example.js</code></p>
                    <pre>
                        <code>
import eventsQueue from './EventsQueue'
eventsQueue.push(pageViewEvent)
                        </code>
                    </pre>
                    <p>This is one the examples of the wonders requestIdleCallback can do.
                        Deferring the execution of analytics code is one of the use cases of rIC. 
                        Another cases might be prefetching the API data for the next page, or downloading
                        the dynamically loaded assets even before user interacts with them.
                    </p>
            </article>
        </section>
    </body>
    <script src="highlight/highlight.pack.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-146419369-1"></script>
    <script>
        window.dataLayer = window.dataLayer || [];
        function gtag(){dataLayer.push(arguments);}
        gtag('js', new Date());

        gtag('config', 'UA-146419369-1');
    </script>
</html>
